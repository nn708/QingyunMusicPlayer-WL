//SMML Standard Package - Duration
//Updated: 2018.2.10.

# Function

Tremolo1(expr, subtrack) {
    /**** (%1-)&2 ****/
    const t = new SubtrackParser(subtrack, this.Settings, this.Libraries).parseTrack()
    const pow = Math.pow(2, -expr)
    const num = Math.round(t.Meta.Duration / pow)
    const result = []
    const length = t.Content.length
    for (let i = 0; i < num; i++) {
        const startTime = i * pow
        for (let j = 0; j < length; j++) {
            result.push(Object.assign({}, t.Content[j]), { StartTime: startTime, Duration: pow })
        }
    }

    return {
        Content: result,
        Meta: t.Meta
    }
}

Tremolo2(expr, subtrack1, subtrack2) {
    /**** &2(%1=)&3 ****/
    const ts = [new SubtrackParser(subtrack1, this.Settings, this.Libraries).parseTrack(), new SubtrackParser(subtrack2, this.Settings, this.Libraries).parseTrack()]
    const pow = Math.pow(2, -expr)
    const num = Math.round(ts[1].Meta.Duration / pow)
    const lengths = ts.map((t) => t.Content.length)
    const result = []
    for (let i = 0; i < num; i++) {
        const startTime = i * pow
        const index = i % 2
        for (let j = 0; j < lengths[index]; j++) {
            result.push(Object.assign({}, ts[index].Content[j], { StartTime: startTime, Duration: pow }))
        }
    }
    return {
        Content: result,
        Meta: {
            Duration: ts[1].Meta.Duration,
            Incomplete: ts[1].Meta.Incomplete,
            Single: true,
            Warnings: [],
            PitchQueue: [...ts[0].Meta.PitchQueue, ...ts[1].Meta.PitchQueue],
            NotesBeforeTie: ts[(num - 1) % 2].Meta.NotesBeforeTie
        }
    }
}

Tuplet(expr, subtrack) {
    /**** (!1~)&2 ****/
    const scale = Math.pow(2, Math.floor(Math.log2(expr))) / expr
    const t = new SubtrackParser(subtrack, this.Settings, this.Libraries).parseTrack()
    t.Content.forEach((note) => {
        note.Duration *= scale
        note.StartTime *= scale
    })
    t.Meta.Duration *= scale
    return t
}

Ferm(ferm) {
    /**** (Ferm:%1) ****/
    this.Settings.assignSetting('Ferm', ferm, (ferm) => ferm > 1)
}

Fermata(subtrack) {
    const t = new SubtrackParser(subtrack, this.Settings, this.Libraries).parseTrack()
    const ferm = this.Settings.getOrSetDefault('Ferm', 2)
    t.Content.forEach((note) => {
        note.Duration *= ferm
        note.StartTime *= ferm
    })
    t.Meta.Duration *= ferm
    return t
}

# End
