//SMML Standard Package - Segment
//Updated: 2018.2.17.

# Function

Seg(r) {
    /**** (Seg:%1) ****/
    AssignSetting(this.Settings, 'Seg', r, (r) => r > 0)
}

GraceNote(subtrack1, subtrack2) {
    /**** (@1^)&2 ****/
    const t1 = new SubtrackParser(subtrack1, this.Settings, this.Libraries, this.pitchQueue).parseTrack()
    const t2 = new SubtrackParser(subtrack2, this.Settings, this.Libraries, this.pitchQueue).parseTrack()
    const num = subtrack1.Content.length
    let dur
    const appo = this.Settings.getOrSetDefault('Seg', 1 / 4)
    if (num <= 4) {
        dur = appo / 4
    } else {
        dur = appo / num
    }
    const actualDur = dur * Math.pow(2, -this.Settings.Duration) * 60 / this.Settings.Speed
    t1.Content.forEach((note) => {
        note.Duration = actualDur 
        note.StartTime *= dur
    })
    const total = actualDur * num
    t2.Content.forEach((note) => {
        note.StartTime += total
        note.Duration -= total
    })
    return {
        Content: [...t1.Content, ...t2.Content],
        Meta: t2.Meta
    }
}

Appoggiatura(subtrack1, subtrack2) {
    /**** &1(^@2) ****/
    const t1 = new SubtrackParser(subtrack1, this.Settings, this.Libraries, this.pitchQueue).parseTrack()
    const t2 = new SubtrackParser(subtrack2, this.Settings, this.Libraries, this.pitchQueue).parseTrack()
    const num = subtrack2.Content.length
    let dur
    const appo = this.Settings.getOrSetDefault('Seg', 1 / 4)
    if (num <= 4) {
        dur = appo / 4
    } else {
        dur = appo / num
    }
    const actualDur = dur * Math.pow(2, -this.Settings.Duration) * 60 / this.Settings.Speed
    const total = actualDur * num
    t1.Content.forEach((note) => {
        note.Duration -= total
    })
    t2.Content.forEach((note) => {
        note.Duration = actualDur
        note.StartTime *= dur
        note.StartTime += t1.Content[0].Duration
    })

    return {
        Content: [...t1.Content, ...t2.Content],
        Meta: t1.Meta
    }
}

Arpeggio(subtrack) {
    /**** \$&1 ****/
    const t = new SubtrackParser(subtrack, this.Settings, this.Libraries, this.pitchQueue).parseTrack()
    const num = t.Content.length - 1
    let dur
    const appo = this.Settings.getOrSetDefault('Seg', 1 / 4)
    if (num <= 4) {
        dur = appo / 4
    } else {
        dur = appo / num
    }
    const actualDur = dur * Math.pow(2, -this.Settings.Duration) * 60 / this.Settings.Speed
    const result = []
    t.Content.reduce((sum, cur, index) => {
        if (index < num) {
            sum.push(cur)
            cur.Duration = actualDur
            for (const note of sum) {
                result.push(Object.assign({}, note, { StartTime: actualDur * index }))
            }
        } else {
            t.Content.forEach((note) => {
                note.StartTime += actualDur * index
                note.Duration -= actualDur * index
            })
            result.push(...t.Content)
        }
        return sum
    }, [])
    return Object.assign(t, {Content: result})
}

# End
