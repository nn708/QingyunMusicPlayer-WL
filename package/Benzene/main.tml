// TM Benzene Package
// Updated: 2018.4.13.

# Function

function _take_(origin, start, end) {
	return this._zoom_(origin.filter(note => {
		return note.StartTime >= start && note.StartTime + note.Duration <= end;
	}), 1, -start);
}

function _adjust_(matrix, source) {
	const mLast = matrix.Meta.BarLast;
	const mBar = matrix.Settings.bar;
	const sLast = source.Meta.BarLast;
	const sBar = source.Settings.bar;
	if (mLast >= mBar) return source;
	if (source.Meta.BarCount === 0) {
		source.Meta.BarCount = Math.floor((mLast + sLast) / sBar);
		if (source.Meta.BarCount > 0) {
			source.Meta.BarFirst = mBar - mLast;
			source.Meta.BarLast = (mLast + sLast) % sBar;
		}
	} else {
		source.Meta.BarCount += Math.floor((mLast + sLast) / sBar);
		source.Meta.BarFirst = (mLast + source.Meta.BarFirst) % mBar;
		source.Meta.BarLast = (mLast + sLast) % sBar;
	}
	return source;
}

function Only() {
	// Alias: Clear
	const settings = {};
	for (property of arguments) {
		settings[property] = this.Settings[property];
		if (settings[property] instanceof Array) {
			settings[property] = settings[property].slice();
		}
	}
	Object.assign(this.Settings, this.newSettings(settings));
}

function Except() {
	const settings = this.newSettings();
	for (property of arguments) {
		this.Settings[property] = settings[property];
	}
}

function Extend(subtrack, beats) {
	// Alias: Rest(${1:int})
	const src = this.ParseTrack(subtrack);
	src.Content.forEach(note => {
		note.Duration = beats * 60 / this.Settings.Speed
	});
	Object.assign(src.Meta, {
		Duration: beats * 60 / this.Settings.Speed,
		BeatCount: beats,
		BarCount: Math.floor(beats / this.Settings.Bar),
		BarFirst: this.Settings.Bar,
		BarLast: beats % this.Settings.Bar
	});
	return src;
}

function Preset(subtrack) {
	const src = this.ParseTrack(subtrack);
	this.Meta.PitchQueue.push(...src.Meta.PitchQueue);
}

function ReplaceRight(subtrack, replacement) {
	const src = this.ParseTrack(subtrack);
	const repl = this.ParseTrack(replacement);
	if (beats < 0) {
		src.Content = this.Library._take_(src.Content, 0, src.Meta.Duration + beats * 60 / src.Settings.Speed);
	}
	return src;
}

function Take(subtrack, beats) {
	const src = this.ParseTrack(subtrack);
	if (beats > 0) {
		this.Library._take_(src.Content, 0, beats * 60 / this.Settings.Speed);
		if (src.Meta.BarCount === 0) {
			src.Meta.BarFirst -= beats;
		} else {
			src.Meta.BarCount -= Math.ceil((beats - src.Meta.BarFirst) / this.Settings.Bar);
			src.Meta.BarFirst = (beats - src.Meta.BarFirst) % this.Settings.Bar;
		}
	} else if (beats < 0) {
		this.Library._take_(src.Content, beats * 60 / src.Settings.Speed, src.Meta.Duration);
		if (src.Meta.BarCount === 0) {
			src.Meta.BarFirst -= beats;
		} else {
			src.Meta.BarCount -= Math.ceil((beats - src.Meta.BarLast) / src.Settings.Bar);
			src.Meta.BarLast = (beats - src.Meta.BarLast) % src.Settings.Bar;
			if (src.Meta.BarCount === 0) src.Meta.BarFirst += src.Meta.BarLast - src.Settings.Bar;
		}
	} else {
		this.ReportError('Arg::ZeroSpec', {});
	}
	return src;
}

function Fill(subtrack, bars) {
	const src = this.ParseTrack(subtrack);
	const time = bars * this.Settings.Bar * 60 / this.Settings.Speed;
	const content = this.Library._fill_(src.Content, src.Meta.Duration, time);
	return this.Library._adjust_(this, {
		Content: content,
		Meta: Object.assign(src.Meta, {
			BarCount: bars,
			BarFirst: this.Settings.Bar,
			BarLast: 0
		}),
		Settings: src.Settings
	});
}

function Map(template, subtrack) {
	const temp = this.ParseTrack(template);
	const src = this.ParseTrack(subtrack);
	const content = [];
	src.Content.forEach(sNote => {
		const sStart = sNote.StartTime * temp.Meta.Duration;
		temp.Content.forEach(tNote => {
			const tStart = tNote.StartTime * sNote.Duration;
			const tempo = 0;
			content.push({
				Type: 'Note',
				Pitch: sNote.Pitch + tNote.Pitch,
				Volume: sNote.Volume * tNote.Volume,
				Duration: sNote.Duration * tNote.Duration,
				StartTime: sStart + tStart
			});
		});
	});
	return this.Library._adjust_(this, {
		Content: content,
		Meta: Object.assign(src.Meta, {
			BarCount: Math.ceil(1)
		}),
		Settings: src.Settings
	});
}

function Apply(template, subtrack) {
	// Alias: ${0:sub}:${1:sub}
	const temp = this.ParseTrack(template, { Settings: this.newSettings() });
	const src = this.ParseTrack(subtrack);
	const scale = temp.Settings.Speed / src.Settings.Speed;
	const proto = this.Library._zoom_(temp.Content, scale);
	const content = [];
	src.Content.forEach(sNote => {
		const filler = this.Library._fill_(proto, temp.Meta.Duration * scale, sNote.Duration);
		content.push(...filler.map(note => Object.assign(note, {
			Pitch: note.Pitch + sNote.Pitch,
			StartTime: note.StartTime + sNote.StartTime,
			StartBeat: note.StartBeat + sNote.StartBeat,
			Volume: note.Volume * sNote.Volume
		})));
	});
	return Object.assign(src, {Content: content});
}

function OctShift(delta) {
	for (let i = 0, length = this.Settings.Key.length; i < length; i++) {
		this.Settings.Key[i] += delta * 12
	}
}

function VolShift(delta) {
	for (let i = 0, length = this.Settings.Volume.length; i < length; i++) {
		this.Settings.Volume[i] *= delta 
	}
}

function SpdShift(delta) {
	this.Settings.Speed *= delta
}

function Bar(bar) {
	this.Settings.assignSetting('Bar', bar, (bar) => bar > 0 && Number.isInteger(bar))
}

function Beat(beat) {
	this.Settings.assignSetting('Beat', beat, (beat) => beat > 0 && Number.isInteger(Math.log2(beat)))
}

# End
